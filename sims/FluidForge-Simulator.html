<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FluidForge: Potential Field Navigation Simulator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .subtitle {
            font-size: 1.1em;
            opacity: 0.95;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 0;
        }

        .canvas-container {
            position: relative;
            background: #f8f9fa;
            padding: 20px;
            border-right: 2px solid #e0e0e0;
        }

        #simulationCanvas {
            width: 100%;
            height: 700px;
            border: 2px solid #667eea;
            border-radius: 10px;
            background: #ffffff;
            cursor: crosshair;
            display: block;
        }

        .controls {
            padding: 30px;
            background: #f8f9fa;
            overflow-y: auto;
            max-height: 750px;
        }

        .control-section {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .control-section h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.2em;
            border-bottom: 2px solid #667eea;
            padding-bottom: 8px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #555;
            font-size: 0.9em;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type="range"] {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: #e0e0e0;
            outline: none;
            -webkit-appearance: none;
            appearance: none()
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            transition: all 0.2s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: #764ba2;
            transform: scale(1.2);
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
            transition: all 0.2s;
        }

        .value-display {
            min-width: 50px;
            text-align: right;
            font-weight: 600;
            color: #667eea;
            font-size: 0.9em;
        }

        button {
            width: 100%;
            padding: 12px;
            margin: 5px 0;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #218838;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 8px 0;
        }

        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .checkbox-group label {
            margin: 0;
            cursor: pointer;
        }

        .stats {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .stats p {
            margin: 5px 0;
            font-size: 0.9em;
        }

        .instructions {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .instructions h4 {
            color: #856404;
            margin-bottom: 10px;
        }

        .instructions ul {
            margin-left: 20px;
            color: #856404;
        }

        .instructions li {
            margin: 5px 0;
        }

        .mode-selector {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .mode-btn {
            padding: 10px;
            border: 2px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }

        .mode-btn.active {
            background: #667eea;
            color: white;
        }

        .mode-btn:hover {
            transform: translateY(-2px);
        }

        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
            }

            .canvas-container {
                border-right: none;
                border-bottom: 2px solid #e0e0e0;
            }

            #simulationCanvas {
                height: 500px;
            }

            .controls {
                max-height: none;
            }
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            h1 {
                font-size: 1.8em;
            }

            .subtitle {
                font-size: 0.9em;
            }

            #simulationCanvas {
                height: 400px;
            }
        }

        .legend {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85em;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 2px solid #333;
        }
        .legend-repulsive-field {
            background: rgba(102, 126, 234, 0.1);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üåä FluidForge</h1>
            <p class="subtitle">Potential Field Navigation Simulator</p>
            <p class="subtitle" style="font-size: 0.9em; margin-top: 5px;">Test swarm algorithms before hardware deployment</p>
        </header>

        <div class="main-content">
            <div class="canvas-container">
                <canvas id="simulationCanvas"></canvas>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #667eea;"></div>
                        <span>Robot</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #28a745;"></div>
                        <span>Goal</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #dc3545;"></div>
                        <div class="legend-color legend-repulsive-field"></div>
                        <span>Repulsive Field</span>
                    <div class="legend-item">
                        <div class="legend-color" style="background: rgba(102, 126, 234, 0.1);"></div>
                        <span>Repulsive Field</span>
                    </div>
                </div>
            </div>

            <div class="controls">
                <div class="instructions">
                    <h4>How to Use</h4>
                    <ul>
                        <li><strong>Click</strong> to place obstacles</li>
                        <li><strong>Right-click</strong> to move goal</li>
                        <li><strong>Drag</strong> obstacles to reposition</li>
                        <li>Adjust parameters in real-time</li>
                        <li>Watch robots flow like water!</li>
                    </ul>
                </div>

                <div class="stats">
                    <p><strong>Active Robots:</strong> <span id="robotCount">3</span></p>
                    <p><strong>Obstacles:</strong> <span id="obstacleCount">0</span></p>
                    <p><strong>FPS:</strong> <span id="fps">0</span></p>
                    <p><strong>Status:</strong> <span id="status">Running</span></p>
                </div>

                <div class="control-section">
                    <h3>‚öôÔ∏è Simulation Control</h3>
                    <button id="playPauseBtn" class="btn-primary">‚è∏Ô∏è Pause</button>
                    <button id="resetBtn" class="btn-secondary">üîÑ Reset Robots</button>
                    <button id="clearObstacles" class="btn-danger">üóëÔ∏è Clear Obstacles</button>
                </div>

                <div class="control-section">
                    <h3>ü§ñ Robot Settings</h3>
                    <div class="control-group">
                        <label>Number of Robots</label>
                        <div class="slider-container">
                            <input type="range" id="robotCountSlider" min="1" max="20" value="3" title="Number of Robots">
                            <span class="value-display" id="robotCountValue">3</span>
                        </div>
                    </div>
                    <div class="control-group">
                        <label>Robot Size</label>
                        <div class="slider-container">
                            <input type="range" id="robotSize" min="5" max="20" value="8" title="Robot Size">
                            <span class="value-display" id="robotSizeValue">8</span>
                        </div>
                    </div>
                    <div class="control-group">
                        <label>Max Speed</label>
                        <div class="slider-container">
                            <input type="range" id="maxSpeed" min="1" max="10" step="0.5" value="3" title="Max Speed">
                            <span class="value-display" id="maxSpeedValue">3</span>
                        </div>
                    </div>
                </div>

                <div class="control-section">
                    <h3>üéØ Force Parameters</h3>
                    <div class="control-group">
                        <label>Attraction Strength (Goal Pull)</label>
                        <div class="slider-container">
                            <input type="range" id="attractionConstant" min="0.1" max="5" step="0.1" value="1.0" title="Attraction Strength (Goal Pull)">
                            <span class="value-display" id="attractionValue">1.0</span>
                        </div>
                    </div>
                    <div class="control-group">
                        <label>Repulsion Strength (Obstacle Push)</label>
                        <div class="slider-container">
                            <input type="range" id="repulsionConstant" min="1" max="50" step="1" value="15" title="Repulsion Strength (Obstacle Push)">
                            <span class="value-display" id="repulsionValue">15</span>
                        </div>
                    </div>
                    <div class="control-group">
                        <label>Swarm Repulsion (Bot Spacing)</label>
                        <div class="slider-container">
                            <input type="range" id="swarmRepulsion" min="0" max="20" step="0.5" value="5" title="Swarm Repulsion (Bot Spacing)">
                            <span class="value-display" id="swarmRepulsionValue">5</span>
                        </div>
                    </div>
                    <div class="control-group">
                        <label>Influence Radius</label>
                        <div class="slider-container">
                            <input type="range" id="influenceRadius" min="20" max="200" step="10" value="100" title="Influence Radius">
                            <span class="value-display" id="influenceRadiusValue">100</span>
                        </div>
                    </div>
                    <div class="control-group">
                        <label>Goal Threshold</label>
                        <div class="slider-container">
                            <input type="range" id="goalThreshold" min="5" max="50" step="5" value="20" title="Goal Threshold">
                            <span class="value-display" id="goalThresholdValue">20</span>
                        </div>
                    </div>
                </div>

                <div class="control-section">
                    <h3>üé® Visualization</h3>
                    <div class="checkbox-group">
                        <input type="checkbox" id="showVectors" checked>
                        <label for="showVectors">Show Force Vectors</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="showField">
                        <label for="showField">Show Repulsive Field</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="showTrails" checked>
                        <label for="showTrails">Show Robot Trails</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="showGoalField">
                        <label for="showGoalField">Show Goal Field</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="showInfluence">
                        <label for="showInfluence">Show Influence Radius</label>
                    </div>
                </div>

                <div class="control-section">
                    <h3>üìö Presets</h3>
                    <button class="btn-success" onclick="loadPreset('default')">Default Settings</button>
                    <button class="btn-success" onclick="loadPreset('tight')">Tight Swarm</button>
                    <button class="btn-success" onclick="loadPreset('loose')">Loose Swarm</button>
                    <button class="btn-success" onclick="loadPreset('obstacle')">Obstacle Course</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============================================================================
        // Vector2D Class
        // ============================================================================
        class Vector2D {
            constructor(x = 0, y = 0) {
                this.x = x;
                this.y = y;
            }

            add(v) {
                return new Vector2D(this.x + v.x, this.y + v.y);
            }

            subtract(v) {
                return new Vector2D(this.x - v.x, this.y - v.y);
            }

            multiply(scalar) {
                return new Vector2D(this.x * scalar, this.y * scalar);
            }

            magnitude() {
                return Math.sqrt(this.x * this.x + this.y * this.y);
            }

            normalize() {
                const mag = this.magnitude();
                if (mag === 0) return new Vector2D(0, 0);
                return new Vector2D(this.x / mag, this.y / mag);
            }

            limit(max) {
                const mag = this.magnitude();
                if (mag > max) {
                    return this.normalize().multiply(max);
                }
                return new Vector2D(this.x, this.y);
            }

            distance(v) {
                const dx = this.x - v.x;
                const dy = this.y - v.y;
                return Math.sqrt(dx * dx + dy * dy);
            }

            static random(minX, maxX, minY, maxY) {
                return new Vector2D(
                    minX + Math.random() * (maxX - minX),
                    minY + Math.random() * (maxY - minY)
                );
            }
        }

        // ============================================================================
        // Robot Class
        // ============================================================================
        class Robot {
            constructor(x, y) {
                this.position = new Vector2D(x, y);
                this.velocity = new Vector2D(0, 0);
                this.acceleration = new Vector2D(0, 0);
                this.trail = [];
                this.maxTrailLength = 50;
                this.size = 8;
            }

            applyForce(force) {
                this.acceleration = this.acceleration.add(force);
            }

            update(maxSpeed) {
                // Update velocity
                this.velocity = this.velocity.add(this.acceleration);
                this.velocity = this.velocity.limit(maxSpeed);

                // Update position
                this.position = this.position.add(this.velocity);

                // Add to trail
                if (sim.showTrails) {
                    this.trail.push({x: this.position.x, y: this.position.y});
                    if (this.trail.length > this.maxTrailLength) {
                        this.trail.shift();
                    }
                }

                // Reset acceleration
                this.acceleration = new Vector2D(0, 0);
            }

            draw(ctx) {
                // Draw trail
                if (sim.showTrails && this.trail.length > 1) {
                    ctx.strokeStyle = 'rgba(102, 126, 234, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(this.trail[0].x, this.trail[0].y);
                    for (let i = 1; i < this.trail.length; i++) {
                        ctx.lineTo(this.trail[i].x, this.trail[i].y);
                    }
                    ctx.stroke();
                }

                // Draw robot body
                ctx.fillStyle = '#667eea';
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#4c5fd5';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw direction indicator
                if (this.velocity.magnitude() > 0.1) {
                    const dir = this.velocity.normalize().multiply(this.size * 1.5);
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(this.position.x, this.position.y);
                    ctx.lineTo(this.position.x + dir.x, this.position.y + dir.y);
                    ctx.stroke();
                }
            }
        }

        // ============================================================================
        // Obstacle Class
        // ============================================================================
        class Obstacle {
            constructor(x, y, radius = 20) {
                this.position = new Vector2D(x, y);
                this.radius = radius;
                this.isDragging = false;
            }

            contains(x, y) {
                const dist = Math.sqrt((x - this.position.x) ** 2 + (y - this.position.y) ** 2);
                return dist < this.radius;
            }

            draw(ctx) {
                // Draw influence radius if enabled
                if (sim.showInfluence) {
                    ctx.strokeStyle = 'rgba(220, 53, 69, 0.2)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(this.position.x, this.position.y, sim.influenceRadius, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Draw obstacle
                ctx.fillStyle = '#dc3545';
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#c82333';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw highlight if dragging
                if (this.isDragging) {
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(this.position.x, this.position.y, this.radius + 5, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
        }

        // ============================================================================
        // Simulation Controller
        // ============================================================================
        const sim = {
            canvas: null,
            ctx: null,
            robots: [],
            obstacles: [],
            goal: null,
            isRunning: true,
            
            // Parameters
            attractionConstant: 1.0,
            repulsionConstant: 15,
            swarmRepulsion: 5,
            influenceRadius: 100,
            goalThreshold: 20,
            maxSpeed: 3,
            robotSize: 8,
            
            // Visualization
            showVectors: true,
            showField: false,
            showTrails: true,
            showGoalField: false,
            showInfluence: false,
            
            // Interaction
            draggedObstacle: null,
            
            // Stats
            fps: 0,
            lastTime: performance.now(), // Initialize with current time
            frameCount: 0,

            init() {
                this.canvas = document.getElementById('simulationCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.resize();
                window.addEventListener('resize', () => this.resize());
                
                // Initialize goal in center
                this.goal = new Vector2D(this.canvas.width / 2, this.canvas.height / 2);
                
                // Create initial robots
                this.createRobots(3);
                
                // Setup controls
                this.setupControls();
                
                // Setup mouse interaction
                this.setupMouseInteraction();
                
                // Start animation loop
                this.animate();
            },

            resize() {
                const rect = this.canvas.getBoundingClientRect();
                const oldWidth = this.canvas.width;
                const oldHeight = this.canvas.height;
                
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
                
                // Scale goal position if canvas was resized
                if (oldWidth > 0 && oldHeight > 0 && this.goal) {
                    const scaleX = this.canvas.width / oldWidth;
                    const scaleY = this.canvas.height / oldHeight;
                    this.goal.x *= scaleX;
                    this.goal.y *= scaleY;
                    
                    // Scale obstacle positions
                    for (let obstacle of this.obstacles) {
                        obstacle.position.x *= scaleX;
                        obstacle.position.y *= scaleY;
                    }
                    
                    // Scale robot positions
                    for (let robot of this.robots) {
                        robot.position.x *= scaleX;
                        robot.position.y *= scaleY;
                        robot.trail = []; // Clear trails on resize
                    }
                }
            },

            createRobots(count) {
                this.robots = [];
                const margin = 50;
                for (let i = 0; i < count; i++) {
                    const pos = Vector2D.random(
                        margin, 
                        this.canvas.width - margin,
                        margin,
                        this.canvas.height - margin
                    );
                    const robot = new Robot(pos.x, pos.y);
                    robot.size = this.robotSize;
                    this.robots.push(robot);
                }
                document.getElementById('robotCount').textContent = this.robots.length;
            },

            setupControls() {
                // Sliders
                this.linkSlider('robotCountSlider', 'robotCountValue', (val) => {
                    this.createRobots(parseInt(val));
                });

                this.linkSlider('robotSize', 'robotSizeValue', (val) => {
                    this.robotSize = parseFloat(val);
                    this.robots.forEach(r => r.size = this.robotSize);
                });

                this.linkSlider('maxSpeed', 'maxSpeedValue', (val) => {
                    this.maxSpeed = parseFloat(val);
                });

                this.linkSlider('attractionConstant', 'attractionValue', (val) => {
                    this.attractionConstant = parseFloat(val);
                });

                this.linkSlider('repulsionConstant', 'repulsionValue', (val) => {
                    this.repulsionConstant = parseFloat(val);
                });

                this.linkSlider('swarmRepulsion', 'swarmRepulsionValue', (val) => {
                    this.swarmRepulsion = parseFloat(val);
                });

                this.linkSlider('influenceRadius', 'influenceRadiusValue', (val) => {
                    this.influenceRadius = parseFloat(val);
                });

                this.linkSlider('goalThreshold', 'goalThresholdValue', (val) => {
                    this.goalThreshold = parseFloat(val);
                });

                // Checkboxes
                document.getElementById('showVectors').addEventListener('change', (e) => {
                    this.showVectors = e.target.checked;
                });

                document.getElementById('showField').addEventListener('change', (e) => {
                    this.showField = e.target.checked;
                });

                document.getElementById('showTrails').addEventListener('change', (e) => {
                    this.showTrails = e.target.checked;
                    if (!e.target.checked) {
                        this.robots.forEach(r => r.trail = []);
                    }
                });

                document.getElementById('showGoalField').addEventListener('change', (e) => {
                    this.showGoalField = e.target.checked;
                });

                document.getElementById('showInfluence').addEventListener('change', (e) => {
                    this.showInfluence = e.target.checked;
                });

                // Buttons
                document.getElementById('playPauseBtn').addEventListener('click', () => {
                    this.isRunning = !this.isRunning;
                    const btn = document.getElementById('playPauseBtn');
                    btn.textContent = this.isRunning ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Play';
                    document.getElementById('status').textContent = this.isRunning ? 'Running' : 'Paused';
                });

                document.getElementById('resetBtn').addEventListener('click', () => {
                    this.createRobots(this.robots.length);
                });

                document.getElementById('clearObstacles').addEventListener('click', () => {
                    this.obstacles = [];
                    document.getElementById('obstacleCount').textContent = '0';
                });
            },

            linkSlider(sliderId, valueId, callback) {
                const slider = document.getElementById(sliderId);
                const valueDisplay = document.getElementById(valueId);
                
                slider.addEventListener('input', (e) => {
                    const val = e.target.value;
                    valueDisplay.textContent = val;
                    callback(val);
                });
            },

            setupMouseInteraction() {
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                this.canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    this.goal = new Vector2D(x, y);
                });

                // Touch support
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.handleMouseDown({
                        clientX: touch.clientX,
                        clientY: touch.clientY,
                        button: 0
                    });
                });

                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.handleMouseMove({
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                });

                this.canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.handleMouseUp(e);
                });
            },

            handleMouseDown(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                // Check if clicking on obstacle
                for (let obstacle of this.obstacles) {
                    if (obstacle.contains(x, y)) {
                        this.draggedObstacle = obstacle;
                        obstacle.isDragging = true;
                        return;
                    }
                }

                // Left click to add obstacle
                if (e.button === 0 && !this.draggedObstacle) {
                    const obstacle = new Obstacle(x, y);
                    this.obstacles.push(obstacle);
                    document.getElementById('obstacleCount').textContent = this.obstacles.length;
                }
            },

            handleMouseMove(e) {
                if (this.draggedObstacle) {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    this.draggedObstacle.position = new Vector2D(x, y);
                }
            },

            handleMouseUp(e) {
                if (this.draggedObstacle) {
                    this.draggedObstacle.isDragging = false;
                    this.draggedObstacle = null;
                }
            },

            calculateAttraction(robot) {
                const direction = this.goal.subtract(robot.position);
                const distance = direction.magnitude();
                
                if (distance < this.goalThreshold) {
                    return new Vector2D(0, 0);
                }
                
                // Use linear attraction proportional to distance
                const strength = Math.min(distance / 100, 1) * this.attractionConstant;
                return direction.normalize().multiply(strength);
            },

            calculateObstacleRepulsion(robot) {
                let totalForce = new Vector2D(0, 0);
                
                for (let obstacle of this.obstacles) {
                    const direction = robot.position.subtract(obstacle.position);
                    const distance = direction.magnitude();
                    
                    // Consider both obstacle radius and influence radius
                    const minDistance = obstacle.radius + robot.size;
                    
                    if (distance < this.influenceRadius && distance > 0) {
                        // Stronger repulsion when very close
                        const effectiveDistance = Math.max(distance - minDistance, 1);
                        const magnitude = this.repulsionConstant / (effectiveDistance * effectiveDistance);
                        const force = direction.normalize().multiply(magnitude);
                        totalForce = totalForce.add(force);
                    }
                }
                
                return totalForce;
            },

            calculateSwarmRepulsion(robot) {
                let totalForce = new Vector2D(0, 0);
                
                for (let otherRobot of this.robots) {
                    if (otherRobot === robot) continue;
                    
                    const direction = robot.position.subtract(otherRobot.position);
                    const distance = direction.magnitude();
                    
                    // Personal space is half the influence radius
                    const personalSpace = this.influenceRadius * 0.5;
                    
                    if (distance < personalSpace && distance > 0) {
                        // Stronger repulsion when robots are very close
                        const effectiveDistance = Math.max(distance, robot.size * 2);
                        const magnitude = this.swarmRepulsion / (effectiveDistance * effectiveDistance);
                        const force = direction.normalize().multiply(magnitude);
                        totalForce = totalForce.add(force);
                    }
                }
                
                return totalForce;
            },

            update() {
                if (!this.isRunning) return;

                // 1. Apply forces and update positions
                for (let robot of this.robots) {
                    // Calculate all forces
                    const attraction = this.calculateAttraction(robot);
                    const obstacleRepulsion = this.calculateObstacleRepulsion(robot);
                    const swarmRepulsion = this.calculateSwarmRepulsion(robot);

                    // Sum all forces
                    const totalForce = attraction
                        .add(obstacleRepulsion)
                        .add(swarmRepulsion);

                    // Apply force and update robot
                    robot.applyForce(totalForce);
                    robot.update(this.maxSpeed);

                    // Keep robots in bounds with proper margin
                    const margin = robot.size + 2;
                    robot.position.x = Math.max(margin, Math.min(robot.position.x, this.canvas.width - margin));
                    robot.position.y = Math.max(margin, Math.min(robot.position.y, this.canvas.height - margin));
                }

                // 2. Resolve collisions between robots (realistic elastic response)
                for (let i = 0; i < this.robots.length; i++) {
                    for (let j = i + 1; j < this.robots.length; j++) {
                        const a = this.robots[i];
                        const b = this.robots[j];
                        const dx = b.position.x - a.position.x;
                        const dy = b.position.y - a.position.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const minDist = a.size + b.size;
                        if (dist < minDist && dist > 0) {
                            // Overlap detected, resolve by separating
                            const overlap = minDist - dist;
                            const nx = dx / dist;
                            const ny = dy / dist;
                            // Move each bot away from the collision point
                            a.position.x -= nx * overlap / 2;
                            a.position.y -= ny * overlap / 2;
                            b.position.x += nx * overlap / 2;
                            b.position.y += ny * overlap / 2;

                            // Exchange velocity components along the collision normal (elastic collision)
                            const va = a.velocity;
                            const vb = b.velocity;
                            // Project velocities onto the normal
                            const va_n = va.x * nx + va.y * ny;
                            const vb_n = vb.x * nx + vb.y * ny;
                            // Swap normal components
                            const va_n_after = vb_n;
                            const vb_n_after = va_n;
                            // Tangential components stay the same
                            const va_t_x = va.x - va_n * nx;
                            const va_t_y = va.y - va_n * ny;
                            const vb_t_x = vb.x - vb_n * nx;
                            const vb_t_y = vb.y - vb_n * ny;
                            // Update velocities
                            a.velocity.x = va_t_x + va_n_after * nx;
                            a.velocity.y = va_t_y + va_n_after * ny;
                            b.velocity.x = vb_t_x + vb_n_after * nx;
                            b.velocity.y = vb_t_y + vb_n_after * ny;
                        }
                    }
                }
            },

            drawField() {
                const gridSize = 30;
                const alpha = 0.1;
                
                for (let x = 0; x < this.canvas.width; x += gridSize) {
                    for (let y = 0; y < this.canvas.height; y += gridSize) {
                        let totalRepulsion = 0;
                        
                        for (let obstacle of this.obstacles) {
                            const dx = x - obstacle.position.x;
                            const dy = y - obstacle.position.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance < this.influenceRadius && distance > obstacle.radius) {
                                const effectiveDistance = distance - obstacle.radius;
                                totalRepulsion += this.repulsionConstant / (effectiveDistance * effectiveDistance);
                            }
                        }
                        
                        if (totalRepulsion > 0) {
                            const intensity = Math.min(totalRepulsion * 10, 255);
                            this.ctx.fillStyle = `rgba(220, 53, 69, ${intensity / 255 * alpha})`;
                            this.ctx.fillRect(x, y, gridSize, gridSize);
                        }
                    }
                }
            },

            drawGoalField() {
                const gridSize = 40;
                this.ctx.strokeStyle = 'rgba(40, 167, 69, 0.3)';
                this.ctx.lineWidth = 1;
                
                for (let x = gridSize; x < this.canvas.width; x += gridSize) {
                    for (let y = gridSize; y < this.canvas.height; y += gridSize) {
                        const pos = new Vector2D(x, y);
                        const direction = this.goal.subtract(pos);
                        const dist = direction.magnitude();
                        
                        if (dist > this.goalThreshold) {
                            const normalized = direction.normalize();
                            const length = Math.min(20, dist / 10);
                            
                            this.ctx.beginPath();
                            this.ctx.moveTo(x, y);
                            this.ctx.lineTo(x + normalized.x * length, y + normalized.y * length);
                            this.ctx.stroke();
                        }
                    }
                }
            },

            drawVectors() {
                for (let robot of this.robots) {
                    const attraction = this.calculateAttraction(robot);
                    const obstacleRepulsion = this.calculateObstacleRepulsion(robot);
                    const swarmRepulsion = this.calculateSwarmRepulsion(robot);
                    
                    const scale = 10;
                    
                    // Draw attraction (green)
                    if (attraction.magnitude() > 0.01) {
                        this.drawArrow(robot.position, attraction.multiply(scale), '#28a745', 2);
                    }
                    
                    // Draw obstacle repulsion (red)
                    if (obstacleRepulsion.magnitude() > 0.01) {
                        this.drawArrow(robot.position, obstacleRepulsion.multiply(scale), '#dc3545', 2);
                    }
                    
                    // Draw swarm repulsion (orange)
                    if (swarmRepulsion.magnitude() > 0.01) {
                        this.drawArrow(robot.position, swarmRepulsion.multiply(scale), '#ff8c00', 1.5);
                    }
                }
            },

            drawArrow(pos, vec, color, width) {
                this.ctx.strokeStyle = color;
                this.ctx.fillStyle = color;
                this.ctx.lineWidth = width;
                
                const end = pos.add(vec);
                
                // Draw line
                this.ctx.beginPath();
                this.ctx.moveTo(pos.x, pos.y);
                this.ctx.lineTo(end.x, end.y);
                this.ctx.stroke();
                
                // Draw arrowhead
                const angle = Math.atan2(vec.y, vec.x);
                const headLength = 8;
                
                this.ctx.beginPath();
                this.ctx.moveTo(end.x, end.y);
                this.ctx.lineTo(
                    end.x - headLength * Math.cos(angle - Math.PI / 6),
                    end.y - headLength * Math.sin(angle - Math.PI / 6)
                );
                this.ctx.lineTo(
                    end.x - headLength * Math.cos(angle + Math.PI / 6),
                    end.y - headLength * Math.sin(angle + Math.PI / 6)
                );
                this.ctx.closePath();
                this.ctx.fill();
            },

            draw() {
                // Clear canvas
                this.ctx.fillStyle = '#ffffff';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw field visualizations
                if (this.showField) {
                    this.drawField();
                }
                
                if (this.showGoalField) {
                    this.drawGoalField();
                }
                
                // Draw goal
                this.ctx.fillStyle = '#28a745';
                this.ctx.beginPath();
                this.ctx.arc(this.goal.x, this.goal.y, 15, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.strokeStyle = '#218838';
                this.ctx.lineWidth = 3;
                this.ctx.stroke();
                
                // Draw goal threshold circle
                this.ctx.strokeStyle = 'rgba(40, 167, 69, 0.3)';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                this.ctx.arc(this.goal.x, this.goal.y, this.goalThreshold, 0, Math.PI * 2);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
                
                // Draw obstacles
                for (let obstacle of this.obstacles) {
                    obstacle.draw(this.ctx);
                }
                
                // Draw force vectors
                if (this.showVectors) {
                    this.drawVectors();
                }
                
                // Draw robots
                for (let robot of this.robots) {
                    robot.draw(this.ctx);
                }
            },

            updateFPS() {
                this.frameCount++;
                const now = performance.now();
                const elapsed = now - this.lastTime;
                
                if (elapsed >= 1000) {
                    this.fps = Math.round(this.frameCount * 1000 / elapsed);
                    document.getElementById('fps').textContent = this.fps;
                    this.frameCount = 0;
                    this.lastTime = now;
                }
            },

            animate() {
                this.update();
                this.draw();
                this.updateFPS();
                requestAnimationFrame(() => this.animate());
            }
        };

        // ============================================================================
        // Presets
        // ============================================================================
        function loadPreset(name) {
            switch(name) {
                case 'default':
                    setSlider('attractionConstant', 'attractionValue', 1.0);
                    setSlider('repulsionConstant', 'repulsionValue', 15);
                    setSlider('swarmRepulsion', 'swarmRepulsionValue', 5);
                    setSlider('influenceRadius', 'influenceRadiusValue', 100);
                    break;
                    
                case 'tight':
                    setSlider('attractionConstant', 'attractionValue', 1.5);
                    setSlider('repulsionConstant', 'repulsionValue', 20);
                    setSlider('swarmRepulsion', 'swarmRepulsionValue', 10);
                    setSlider('influenceRadius', 'influenceRadiusValue', 80);
                    break;
                    
                case 'loose':
                    setSlider('attractionConstant', 'attractionValue', 0.8);
                    setSlider('repulsionConstant', 'repulsionValue', 10);
                    setSlider('swarmRepulsion', 'swarmRepulsionValue', 2);
                    setSlider('influenceRadius', 'influenceRadiusValue', 150);
                    break;
                    
                case 'obstacle':
                    sim.obstacles = [];
                    // Create obstacle course
                    const w = sim.canvas.width;
                    const h = sim.canvas.height;
                    sim.obstacles.push(new Obstacle(w * 0.3, h * 0.3, 30));
                    sim.obstacles.push(new Obstacle(w * 0.7, h * 0.3, 30));
                    sim.obstacles.push(new Obstacle(w * 0.5, h * 0.5, 40));
                    sim.obstacles.push(new Obstacle(w * 0.3, h * 0.7, 30));
                    sim.obstacles.push(new Obstacle(w * 0.7, h * 0.7, 30));
                    document.getElementById('obstacleCount').textContent = sim.obstacles.length;
                    break;
            }
        }

        function setSlider(sliderId, valueId, value) {
            const slider = document.getElementById(sliderId);
            const valueDisplay = document.getElementById(valueId);
            if (slider && valueDisplay) {
                slider.value = value;
                valueDisplay.textContent = value;
                slider.dispatchEvent(new Event('input'));
            }
        }

        // ============================================================================
        // Initialize
        // ============================================================================
        window.addEventListener('load', () => {
            sim.init();
        });
    </script>
</body>
</html>